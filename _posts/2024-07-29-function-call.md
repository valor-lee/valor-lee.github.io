---
title: '함수 호출에 대해서' 
date: 2024-07-29 19:29:00 +09:00
categories: [computer]
tags:
  [
    computer
  ]
---


# 개요

하드웨어 관점에서 함수를 호출하는 과정과 그에 따른 비용은 여러 요소에 의해 결정됩니다. 

여기서는 CPU 레지스터, 스택, 메모리 등의 역할을 중심으로 함수 호출 과정과 비용을 설명하겠습니다.

# 함수 호출 과정

![image](https://github.com/user-attachments/assets/57e87705-d08e-4e82-a2ad-a583750a40ea)
- 운영체제가 제공하는 메모리 공간

## 1. 현재 상태 저장 (Save State)

- 함수가 호출되면 현재 함수의 실행 상태를 저장해야 합니다. 이는 주로 **레지스터에 저장된 값들을 스택에 푸시(push)하는 방식**으로 이루어집니다.
- 호출자 함수는 호출한 함수가 반환된 후에도 자신의 작업을 계속할 수 있어야 하므로, 레지스터 값을 보존해야 합니다.

## 2. 매개변수 전달 (Parameter Passing)

- 함수에 전달할 매개변수들은 일반적으로 레지스터나 스택을 통해 전달됩니다.
- 많은 시스템에서 <span style="background-color:green;font-weight:bold;">첫 몇 개의 매개변수는 레지스터를 통해 전달되고, 나머지는 스택을 통해 전달</span>됩니다.

## 3. 함수 호출 (Call)

- 함수의 주소를 호출하여 **프로그램 카운터(Program Counter, PC)**를 해당 주소로 설정합니다. 이는 CPU의 call 명령어를 통해 이루어집니다.
- 프로그램 카운터는 현재 실행 중인 명령어의 주소를 가리키므로, 호출된 함수의 첫 번째 명령어를 실행하기 위해 업데이트됩니다.

> **프로그램 카운터**
> 
> ![image](https://github.com/user-attachments/assets/cbbb36b2-50bd-4008-8c64-6ff79be27fec)
> - 마이크로프로세서 내부에 있는 레지스터 중 하나로, 다음에 실행될 명령어의 주소를 가지고 있어서 실행할 코드의 위치를 지정한다.
> - 이로 인해 명령어 포인터라고도 한다.
>
>> IR 레지스터
>> - 명령어를 가져오기 위한 레지스터


## 4. 새 스택 프레임 생성 (Create New Stack Frame)

![stack frame](https://github.com/user-attachments/assets/1640d341-f0c8-44bf-809c-e0834ce0123c)
- 새로운 함수의 **스택 프레임**이 메모리 스택 영역에 생성됩니다.
  - 함수 호출 시 지역 변수, 매개변수, 반환 주소 등의 저장을 위해 할당되는 메모리 블록
- 함수가 시작될 때 **스택 포인터**(Stack Pointer, SP)를 조정하여 새 스택 프레임을 설정합니다.
- fct2()함수가 호출되면 e, h 지역변수를 스텍에 할당하는데, 이때 메모리블록을 fct2 함수의 스택 프레임을 의미합니다.
- fct2 함수를 스택 프레임도 반환합니다.

> 스택 포인터
>
> ![stack pointer](https://github.com/user-attachments/assets/75be1398-dc48-4c4a-b47f-69418f9b3037)
> - 스택의 가장 위쪽(최종) 데이터의 위치를 가리키는 레지스터로, 스택프레임 단위의 삽입 / 삭제를 수행합니다.
> - 데이터를 삽입할 때는 포인터를 먼저 증가시킨 다음, 그 위치에 데이터를 저장합니다.


## 5. 함수 실행 (Function Execution)

- 함수의 본문이 실행됩니다. 이는 일반적인 명령어 실행 과정과 동일합니다.
- 함수는 자신의 작업을 수행하고, 지역 변수와 임시 데이터를 처리합니다.

## 6. 함수 반환 (Return)

- 함수가 종료되면 반환값을 호출자에게 전달합니다. 이는 일반적으로 특정 레지스터에 반환값을 저장하는 방식으로 이루어집니다.
- CPU의 `ret` 명령어를 사용하여 반환 주소로 복귀합니다.

## 7. 이전 상태 복원 (Restore State)

![image](https://github.com/user-attachments/assets/a80cf6cc-206a-4fb3-ba4b-0e4d88f53cb2)

- 함수 호출 전에 저장한 레지스터 값들을 스택에서 복원합니다. 이는 호출자 함수의 실행 상태를 복원하기 위함입니다.
- **프레임 포인터 레지스터**로부터 되돌아 갈 스택 포인터 위치를 받아 이전 스택 프레임을 복원합니다.

> 프레임 포인터(Frame Pointer) 레지스터
>
> - 현재 함수 전 SP 위치를 저장하는 레지스터
> - 새 함수를 호출할 때 현재 함수의 SP레지스터에 저장된 값을 FP레지스터에 저장함
> - 함수가 반환될 때 FP 레지스터 값을 참조하여 SP 레지스터를 이전 함수의 스텍 프레임 최종 위치로 되돌린다.



<br>

# 함수 호출 시 발생하는 비용

함수 호출에는 아래와 같은 비용이 발생할 수 있습니다.

## 1. 명령어 실행 비용

- 함수 호출과 반환을 위한 명령어(`call` 및 `ret`)를 실행하는 데 필요한 CPU 사이클.


## 2. 메모리 접근 비용

- 레지스터 값을 스택에 푸시하고 팝하는 과정에서의 메모리 접근 비용이 발생합니다.
- 매개변수를 스택을 통해 전달하는 경우, 스택 메모리 접근 비용이 발생합니다.


## 3. 캐시 미스 비용
- 함수 호출로 인해 새로운 코드가 실행되면서 명령어 캐시(instruction cache)와 데이터 캐시(data cache)의 미스가 발생할 수 있습니다.
- 특히, **자주 호출되는 작은 함수는 캐시 히트율을 높일 수 있지만, 큰 함수나 자주 호출되지 않는 함수는 캐시 효율성을 떨어뜨릴 수 있습니다.**

## 4. 브랜치 예측 실패 비용

- 함수 호출은 간접 분기(indirect branch)로 간주되며, 브랜치 예측이 실패할 경우 성능 저하를 초래할 수 있습니다.

> 브랜치 예측(branch prediction)
> - 다음 실행될 조건문이 어떤 곳으로 분기할 것인지를 확실히 알기 전에 미리 추측하는 CPU 기술


## 5. 파이프라인 플러시 비용

- 함수 호출과 반환은 파이프라인 플러시를 유발할 수 있습니다.

> 파이프라인 플러시
> - CPU가 현재 실행 중인 명령어들을 버리고 새로운 명령어들을 로드해야 함을 의미합니다.

# 최적화 고려 사항

이러한 함수 호출 비용을 줄이기 위해 여러 가지 최적화 기법이 사용할 수 있습니다.


## 1. 인라인 함수 (Inline Functions)

작은 함수의 경우, 컴파일러가 함수 호출을 인라인으로 대체하여 호출 오버헤드를 제거할 수 있습니다.

## 2. 레지스터 매개변수 전달

매개변수를 레지스터를 통해 전달함으로써 스택 접근을 줄이고 성능을 향상시킬 수 있습니다.


## 3. 테일 호출 최적화 (Tail Call Optimization)

함수의 마지막 명령어가 또 다른 함수를 호출하는 경우, 스택 프레임을 재사용하여 오버헤드를 줄이는 기법.

## 4. 루프 언롤링 (Loop Unrolling)

- 반복적인 함수 호출을 줄이기 위해 루프를 언롤링하여 성능을 향상시킬 수 있습니다.


# 마무리

함수 호출은 필수적인 프로그래밍 개념이지만, 하드웨어 관점에서 다양한 비용이 수반됩니다. 이러한 비용을 이해하고 적절히 최적화하는 것이 시스템 성능을 높이는 데 중요합니다.

각각의 기법의 의미를 예시를 기반으로 좀 더 학습해나가보겠습니다.



---

참조
- https://www.tcpschool.com/c/c_memory_structure
- https://dakuo.tistory.com/102